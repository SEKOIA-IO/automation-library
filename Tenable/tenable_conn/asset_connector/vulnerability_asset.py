from datetime import timedelta, datetime
from functools import cached_property
from typing import Generator
from enum import StrEnum

from sekoia_automation.asset_connector.models.ocsf.device import (
    Device,
    NetworkInterface,
    NetworkInterfaceTypeId,
    NetworkInterfaceTypeStr,
    GeoLocation,
    OperatingSystem,
    OSTypeId,
    OSTypeStr,
    DeviceTypeId,
    DeviceTypeStr,
)
from tenable.io import TenableIO

from sekoia_automation.asset_connector import AssetConnector
from sekoia_automation.checkpoint import CheckpointTimestamp, TimeUnit
from sekoia_automation.asset_connector.models.ocsf.base import Product, Metadata
from sekoia_automation.asset_connector.models.ocsf.vulnerability import (
    VulnerabilityOCSFModel,
    FindingInformation,
    CVE,
    VulnerabilityDetails,
    CVSS,
    KillChain,
    KillChainPhase,
    KillChainPhaseID,
)

from tenable_conn import TenableModule


class VulnerabilityState(StrEnum):
    OPEN = "open"
    REOPENED = "reopened"
    FIXED = "fixed"


class VulnerabilitySeverity(StrEnum):
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class TenableAssetConnector(AssetConnector):
    module: TenableModule

    STATES: list[VulnerabilityState] = []
    SEVERITIES: list[VulnerabilitySeverity] = []
    PRODUCT: str = "Tenable"
    PRODUCT_TYPE: str = "Tenable Vulnerability Management"
    CLIENT_PRODUCT: str = "Sekoia Defend"
    CLIENT_VENDOR: str = "Sekoia.io"

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

        self.num_assets = 1000
        self.cursor = CheckpointTimestamp(
            path=self._data_path,
            time_unit=TimeUnit.SECOND,
            start_at=timedelta(days=120),
        )
        self._latest_time = self.cursor.offset

    @property
    def client(self) -> TenableIO:
        try:
            return TenableIO(
                url=self.module.configuration.base_url,
                access_key=self.module.configuration.access_key,
                secret_key=self.module.configuration.secret_key,
                vendor=self.CLIENT_VENDOR,
                product=self.CLIENT_PRODUCT,
            )
        except Exception as e:
            self.log_exception(e, message="Failed to initialize Tenable client")
            raise

    @cached_property
    def states(self) -> list[str]:
        """
        Get the list of vulnerability states.
        :return:
            list[str]: A list of vulnerability state values.
        """
        state_list = []
        for state in VulnerabilityState:
            state_list.append(str(state.value))
        return state_list

    @cached_property
    def severities(self) -> list[str]:
        """
        Get the list of vulnerability severities.
        :return:
            list[str]: A list of vulnerability severity values.
        """
        sev_list = []
        for severity in VulnerabilitySeverity:
            sev_list.append(str(severity.value))
        return sev_list

    def extract_timestamp(self, vuln: dict, field: str = "first_found") -> int:
        try:
            dt = datetime.fromisoformat(vuln[field])
            return int(dt.timestamp())
        except (KeyError, ValueError, TypeError) as e:
            self.log(f"Failed to extract timestamp from field '{field}': {e}", level="warning")
            return int(self._latest_time)

    def handle_activity(self, state: str) -> tuple[int | None, str | None]:
        action_map = {
            "OPEN": (1, "Create"),
            "REOPENED": (2, "Updated"),
            "FIXED": (3, "Close"),
        }
        return action_map.get(state, (None, None))

    def _extract_cvss_info(self, plugin: dict) -> list[CVSS] | None:
        cvss_list = []

        if plugin.get("cvss_base_score"):
            cvss_list.append(CVSS(version="2.0", base_score=float(plugin["cvss_base_score"])))

        if plugin.get("cvss3_base_score"):
            cvss_list.append(CVSS(version="3.0", base_score=float(plugin["cvss3_base_score"])))

        return cvss_list if cvss_list else None

    def _parse_datetime_to_timestamp(self, datetime_str: str | None) -> int | None:
        if not datetime_str:
            return None
        try:
            dt = datetime.fromisoformat(datetime_str.replace("Z", "+00:00"))
            return int(dt.timestamp())
        except (ValueError, AttributeError, TypeError) as e:
            self.log(f"Failed to parse datetime '{datetime_str}': {e}", level="warning")
            return None

    def _map_os_type(self, os_name: str | None) -> tuple[OSTypeStr, OSTypeId]:
        if not os_name:
            return OSTypeStr.UNKNOWN, OSTypeId.UNKNOWN

        os_lower = os_name.lower()

        os_mappings = [
            (["windows mobile"], (OSTypeStr.WINDOWS_MOBILE, OSTypeId.WINDOWS_MOBILE)),
            (["windows"], (OSTypeStr.WINDOWS, OSTypeId.WINDOWS)),
            (["linux", "centos", "ubuntu", "debian", "red hat", "rhel"], (OSTypeStr.LINUX, OSTypeId.LINUX)),
            (["android"], (OSTypeStr.ANDROID, OSTypeId.ANDROID)),
            (["macos", "mac os"], (OSTypeStr.MACOS, OSTypeId.MACOS)),
            (["ios"], (OSTypeStr.IOS, OSTypeId.IOS)),
            (["ipados"], (OSTypeStr.IPADOS, OSTypeId.IPADOS)),
            (["solaris"], (OSTypeStr.SOLARIS, OSTypeId.SOLARIS)),
            (["aix"], (OSTypeStr.AIX, OSTypeId.AIX)),
            (["hp-ux", "hpux"], (OSTypeStr.HPUX, OSTypeId.HPUX)),
        ]

        for keywords, os_type in os_mappings:
            if any(keyword in os_lower for keyword in keywords):
                return os_type

        return OSTypeStr.OTHER, OSTypeId.OTHER

    def _map_device_type(self, system_type: str | None) -> tuple[DeviceTypeStr, DeviceTypeId]:
        if not system_type:
            return DeviceTypeStr.UNKNOWN, DeviceTypeId.UNKNOWN

        type_lower = system_type.lower()

        type_mappings = [
            (["server", "general-purpose"], (DeviceTypeStr.SERVER, DeviceTypeId.SERVER)),
            (["desktop"], (DeviceTypeStr.DESKTOP, DeviceTypeId.DESKTOP)),
            (["laptop"], (DeviceTypeStr.LAPTOP, DeviceTypeId.LAPTOP)),
            (["tablet"], (DeviceTypeStr.TABLET, DeviceTypeId.TABLET)),
            (["mobile"], (DeviceTypeStr.MOBILE, DeviceTypeId.MOBILE)),
            (["virtual", "vm"], (DeviceTypeStr.VIRTUAL, DeviceTypeId.VIRTUAL)),
            (["iot"], (DeviceTypeStr.IOT, DeviceTypeId.IOT)),
            (["firewall"], (DeviceTypeStr.FIREWALL, DeviceTypeId.FIREWALL)),
            (["switch"], (DeviceTypeStr.SWITCH, DeviceTypeId.SWITCH)),
            (["router"], (DeviceTypeStr.ROUTER, DeviceTypeId.ROUTER)),
        ]

        for keywords, device_type in type_mappings:
            if any(keyword in type_lower for keyword in keywords):
                return device_type

        return DeviceTypeStr.OTHER, DeviceTypeId.OTHER

    def _build_network_interfaces(self, interfaces_data: list[dict]) -> list[NetworkInterface]:

        if not interfaces_data:
            return []

        network_interfaces = []
        wireless_keywords = ["wireless", "wi-fi", "wifi", "wlan", "802.11"]
        mobile_keywords = ["mobile", "cellular", "wwan", "4g", "5g", "lte"]
        tunnel_keywords = ["tun", "tap", "docker", "vpn", "virtual", "cni"]

        for iface in interfaces_data:
            interface_type = NetworkInterfaceTypeStr.UNKNOWN
            interface_type_id = NetworkInterfaceTypeId.UNKNOWN

            raw_name = iface.get("name", "")
            name_lower = raw_name.lower()

            if iface.get("virtual") is True or any(k in name_lower for k in tunnel_keywords):
                interface_type = NetworkInterfaceTypeStr.TUNNEL
                interface_type_id = NetworkInterfaceTypeId.TUNNEL
            elif any(k in name_lower for k in mobile_keywords):
                interface_type = NetworkInterfaceTypeStr.MOBILE
                interface_type_id = NetworkInterfaceTypeId.MOBILE
            elif any(k in name_lower for k in wireless_keywords):
                interface_type = NetworkInterfaceTypeStr.WIRELESS
                interface_type_id = NetworkInterfaceTypeId.WIRELESS
            elif raw_name and "catch_all" not in name_lower:
                interface_type = NetworkInterfaceTypeStr.WIRED
                interface_type_id = NetworkInterfaceTypeId.WIRED

            ipv4_list = iface.get("ipv4", [])
            mac_list = iface.get("mac_address", [])
            fqdn_list = iface.get("fqdn", [])

            if fqdn_list or ipv4_list or mac_list or raw_name:
                network_interfaces.append(
                    NetworkInterface(
                        hostname=fqdn_list[0] if fqdn_list else None,
                        ip=ipv4_list[0] if ipv4_list else None,
                        mac=mac_list[0] if mac_list else None,
                        name=raw_name,
                        type=interface_type,
                        type_id=interface_type_id,
                    )
                )

        return network_interfaces

    def _build_device_from_asset(self, asset_info: dict) -> Device:
        system_types = asset_info.get("system_type", [])
        device_type_str, device_type_id = self._map_device_type(system_types[0] if system_types else None)

        os_list = asset_info.get("operating_system", [])
        os_type_str, os_type_id = self._map_os_type(os_list[0] if os_list else None)

        operating_system = (
            OperatingSystem(name=os_list[0], type=os_type_str, type_id=os_type_id) if os_list else None
        )

        interfaces_data = asset_info.get("interfaces", [])
        network_interfaces = self._build_network_interfaces(interfaces_data) if interfaces_data else None

        geo_location = None
        aws_region = asset_info.get("aws_region", [])
        azure_location = asset_info.get("azure_location", [])
        gcp_zone = asset_info.get("gcp_zone", [])

        if aws_region or azure_location or gcp_zone:
            location_str = (
                aws_region[0]
                if aws_region
                else (azure_location[0] if azure_location else (gcp_zone[0] if gcp_zone else None))
            )
            if location_str:
                geo_location = GeoLocation(country=None, city=location_str)

        hostname = (
            asset_info.get("name")
            or (asset_info.get("hostname", [None])[0] if asset_info.get("hostname") else None)
            or (asset_info.get("fqdn", [None])[0] if asset_info.get("fqdn") else None)
            or "unknown"
        )

        is_managed = asset_info.get("has_agent", False)

        return Device(
            uid=asset_info.get("id", "unknown"),
            type=device_type_str,
            type_id=device_type_id,
            hostname=hostname,
            name=asset_info.get("name"),
            os=operating_system,
            location=geo_location,
            ip=asset_info.get("ipv4", [None])[0] if asset_info.get("ipv4") else None,
            network_interfaces=network_interfaces,
            first_seen_time=self._parse_datetime_to_timestamp(asset_info.get("first_seen")),
            last_seen_time=self._parse_datetime_to_timestamp(asset_info.get("last_seen")),
            created_time=self._parse_datetime_to_timestamp(asset_info.get("created_at")),
            is_managed=is_managed,
            vendor_name="Tenable",
        )

    def map_vulnerability_fields(self, vuln: dict, asset_info: dict) -> VulnerabilityOCSFModel:
        plugin = vuln.get("plugin", {})
        vuln_state = vuln.get("state", "OPEN")
        activity_id, activity_status = self.handle_activity(vuln_state)

        type_uid = 200200 + int(activity_id) if activity_id else 200200
        type_name = (
            f"Vulnerability Finding: {activity_status}" if activity_status else "Vulnerability Finding: Unknown"
        )

        product = Product(name=self.PRODUCT, version=plugin.get("version", "N/A"))
        metadata = Metadata(product=product, version="1.6.0")

        cve_ids = plugin.get("cve", [])
        cve = CVE(
            uid=",".join(cve_ids) if cve_ids else "N/A",
            type="CVE" if cve_ids else None,
            cvss=self._extract_cvss_info(plugin),
            desc=plugin.get("description", ""),
            title=plugin.get("name", ""),
        )

        vulnerabilities = VulnerabilityDetails(
            cve=cve,
            title=plugin.get("name", ""),
            desc=plugin.get("description", ""),
            references=plugin.get("see_also", []),
            severity=vuln.get("severity", "").lower(),
            vendor_name=self.PRODUCT,
        )

        finding_product = Product(name=self.PRODUCT_TYPE, version="N/A")
        finding_information = FindingInformation(
            uid=vuln.get("finding_id", "unknown"),
            types=[plugin.get("type")] if plugin.get("type") else [],
            data_sources=[vuln.get("source")] if vuln.get("source") else [],
            title=plugin.get("name", ""),
            desc=plugin.get("synopsis", "") or plugin.get("description", ""),
            src_url=plugin.get("see_also", [None])[0] if plugin.get("see_also") else None,
            first_seen_time=self.extract_timestamp(vuln, "first_found"),
            last_seen_time=self.extract_timestamp(vuln, "last_found"),
            created_time=self._parse_datetime_to_timestamp(plugin.get("publication_date")),
            product=finding_product,
            kill_chain=[KillChain(phase=KillChainPhase.OTHER, phase_id=KillChainPhaseID.OTHER)],
        )

        device = self._build_device_from_asset(asset_info)

        confidence_score = plugin.get("vpr_v2", {}).get("score")
        confidence = None
        confidence_id = None

        if confidence_score:
            if confidence_score >= 7.0:
                confidence = "High"
                confidence_id = 3
            elif confidence_score >= 4.0:
                confidence = "Medium"
                confidence_id = 2
            else:
                confidence = "Low"
                confidence_id = 1

        return VulnerabilityOCSFModel(
            activity_id=activity_id,
            activity_name=activity_status,
            category_name="Findings",
            category_uid=2,
            class_name="Vulnerability Finding",
            class_uid=2002,
            type_name=type_name,
            type_uid=type_uid,
            time=self.extract_timestamp(vuln, "first_found"),
            metadata=metadata,
            finding_info=finding_information,
            vulnerabilities=vulnerabilities,
            device=device,
            confidence=confidence,
            confidence_id=confidence_id,
            confidence_score=int(confidence_score) if confidence_score else None,
        )

    def update_checkpoint(self) -> None:
        try:
            self.cursor.offset = self._latest_time
            self.from_date = self._latest_time
        except Exception as e:
            self.log_exception(e, message="Failed to update checkpoint")

    def _get_asset_info(self, asset_uuid: str) -> dict | None:
        try:
            asset_info: dict = self.client.assets.details(asset_uuid)
            return asset_info
        except Exception as e:
            self.log(f"Failed to get asset info for {asset_uuid}: {e}", level="error")
            return None

    def _get_tenable_vul(self) -> Generator[VulnerabilityOCSFModel, None, None]:
        try:
            recent_timestamp_seen: int = self._latest_time
            self.log(f"Getting vulnerabilities from Tenable at {self.cursor.offset}", level="info")

            vulns = self.client.exports.vulns(
                since=recent_timestamp_seen,
                state=self.states,
                severity=self.severities,
                num_assets=self.num_assets,
            )

            if not vulns:
                self.log(f"No vulnerabilities found from Tenable at {self.cursor.offset}", level="info")
                return

            for vuln in vulns:
                try:
                    if not vuln:
                        self.log("Empty vulnerability record, skipping", level="warning")
                        continue

                    asset_uuid = vuln.get("asset", {}).get("uuid")

                    if not asset_uuid:
                        self.log("Vulnerability missing asset UUID, skipping", level="warning")
                        continue

                    asset_info = self._get_asset_info(asset_uuid)
                    if not asset_info:
                        self.log(f"Could not retrieve asset info for {asset_uuid}, skipping", level="warning")
                        continue

                    mapped_vuln = self.map_vulnerability_fields(vuln, asset_info)
                    if mapped_vuln:
                        yield mapped_vuln

                        last_datetime: int = self.extract_timestamp(vuln)
                        if last_datetime > recent_timestamp_seen:
                            self._latest_time = last_datetime
                            self.log(f"Latest time updated to {last_datetime}", level="debug")
                except Exception as e:
                    self.log_exception(
                        e, message=f"Failed to process vulnerability {vuln.get('finding_id', 'unknown')}"
                    )
                    continue

        except Exception as e:
            self.log_exception(e, message="Failed to retrieve vulnerabilities from Tenable")

    def get_assets(self) -> Generator[VulnerabilityOCSFModel, None, None]:
        self.log("Starting Tenable asset connector", level="info")
        try:
            for vuln in self._get_tenable_vul():
                yield vuln
        except Exception as e:
            self.log_exception(e, message=f"Error in asset generator : {e}")
