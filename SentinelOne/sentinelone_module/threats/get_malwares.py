import hashlib
import io
import time
from collections.abc import Generator
from datetime import datetime, timezone
from zipfile import BadZipFile, ZipFile

from management.mgmtsdk_v2.services.activity import ActivitiesFilter
from management.mgmtsdk_v2.services.threat import ThreatQueryFilter
from pydantic import BaseModel, Field

from sentinelone_module.base import SentinelOneAction
from sentinelone_module.exceptions import GetMalwaresError, GetMalwaresFailedError, GetMalwaresTimeoutError
from sentinelone_module.helpers import generate_password, to_rfc3339
from sentinelone_module.threats import ThreatFilters


class GetMalwaresArguments(BaseModel):
    filters: ThreatFilters | None
    threat_id: str
    timeout: int

    def get_query_filters(self):
        query_filter = self.filters.to_query_filter() if self.filters else ThreatQueryFilter()
        query_filter.apply("ids", val=[self.threat_id])
        return query_filter


class GetMalwareFile(BaseModel):
    path: str


class GetMalwaresResult(BaseModel):
    status: str | None
    status_reason: str | None
    files: list[GetMalwareFile] | list[dict[str, str]] = Field(default_factory=list)


class GetMalwaresAction(SentinelOneAction):
    name = "Get malware from threat"
    description = "Get the malicious file associated to a threat"
    results_model = GetMalwaresResult

    def _wait_for_activity(self, threat_id: str, timeout: int, from_date: datetime) -> dict:
        query_filter = ActivitiesFilter()
        query_filter.apply(key="threatIds", val=[threat_id])
        query_filter.apply(key="limit", val=1000)
        query_filter.apply(key="sortBy", val="createdAt")
        query_filter.apply(key="sortOrder", val="desc")
        query_filter.apply(key="createdAt", val=to_rfc3339(from_date), op="gt")

        start = time.time()
        while start + timeout > time.time():
            cursor = None
            has_more_items = True
            while has_more_items:
                if cursor:
                    query_filter.apply(key="cursor", val=cursor)

                result = self.client.activities.get(query_filter=query_filter)

                for activity in result.json["data"]:
                    if activity["activityType"] == 86 and len(activity["data"].get("downloadUrl", "")) > 0:
                        return activity

                cursor = result.pagination["nextCursor"]
                has_more_items = cursor is not None

            time.sleep(min(timeout, 10))

        raise GetMalwaresTimeoutError(timeout)

    def _fetch_content(self, activity: dict, password: str) -> Generator[str, None, None]:
        result = self.client.client.get(activity["data"]["downloadUrl"][1:])

        if result.status_code > 399:
            self.log("Failed to download the malware", level="warning")
            raise GetMalwaresFailedError("Unable to download the archive")

        try:
            archive = ZipFile(io.BytesIO(result.response.content))
            archive.setpassword(password.encode("utf-8"))

            filenames = set(archive.namelist()) - {"manifest.json"}
            for filename in filenames:
                content = archive.read(filename)
                destination_name = hashlib.sha1(content).hexdigest()
                with self._data_path.joinpath(destination_name).open("wb") as f:
                    f.write(content)

                yield destination_name
        except BadZipFile as error:
            self.log(f"Unable to unzip the archive: {error}", level="error")
            raise GetMalwaresFailedError("Unable to unzip the archive") from error
        except RuntimeError as error:
            self.log(f"Unable to read the archive: {error}", level="error")
            raise GetMalwaresFailedError("Unable to read the archive") from error

    def run(self, arguments: GetMalwaresArguments):
        password = generate_password()

        now = datetime.now(timezone.utc)
        result = self.client.threats.fetch_files(
            password=password,
            query_filter=arguments.get_query_filters(),
        )

        if result.json["data"].get("affected", 0) == 0:
            return GetMalwaresResult(status="failed", status_reason="No agent affected")

        try:
            activity = self._wait_for_activity(arguments.threat_id, arguments.timeout, now)

            files = [{"path": path} for path in self._fetch_content(activity, password)]
            return GetMalwaresResult(
                status="succeed",
                status_reason="The malware was successfully retrieved",
                files=files,
            )

        except GetMalwaresError as error:
            return GetMalwaresResult(status=error.status, status_reason=str(error))
