# Trigger

## Overview

A trigger is the initiating component of a playbook that monitors for events and launches playbook runs when new events are detected. Triggers continuously monitor external systems, APIs, or data sources and create playbook execution instances.

See [official documentation](https://docs.sekoia.io/xdr/features/automate/triggers/) for end-user perspective.

## Trigger vs Connector

**Trigger**: Monitors events and launches playbook runs by calling `send_event()`  
**Connector**: Collects events and forwards them to Sekoia.io intake without launching playbooks

See [Connector documentation](connector.md) for details on connectors.

## Trigger Components

Each trigger consists of TWO required components:

### 1. Manifest File (JSON)

**Location**: Module root directory  
**Naming convention**: `trigger_<name>.json`

#### Manifest Schema

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `uuid` | string (UUID) | Yes | Unique identifier for the trigger (MUST NOT change) |
| `name` | string | Yes | Human-readable trigger name |
| `description` | string | Yes | Brief description of what the trigger monitors |
| `docker_parameter` | string | Yes | Unique command name for trigger registration |
| `arguments` | object (JSON Schema) | Yes | Configuration schema for the trigger |
| `results` | object (JSON Schema) | Yes | Schema for events generated by the trigger |

#### Important Notes

- The `uuid` is the trigger's permanent identifier. **Changing it is a breaking change.**
- The `arguments` field defines trigger-specific configuration (e.g., polling interval, filters)
- The `results` field defines the event data structure passed to playbook runs
- Both use [JSON Schema](https://json-schema.org/) format

### 2. Python Implementation

**Location**: `<module_name>_module/` directory

#### Class Structure

A trigger class MUST:

1. **Inherit from** [`Trigger`](https://github.com/SEKOIA-IO/sekoia-automation-sdk/blob/main/sekoia_automation/trigger.py) (from `sekoia-automation-sdk`)
2. **Implement the `run()` method**:
   - Contains monitoring logic (typically an infinite loop)
   - Calls `self.send_event()` to launch playbook runs
   - Handles polling intervals and error recovery

#### Event Generation

When a new event is detected, call `self.send_event()` with the event data:

```python
self.send_event(
    event_name="User Created",
    event_data=event_payload,
    directory="optional_subdirectory"
)
```

This launches a new playbook run with the provided event data.

**Example**:
```python
from sekoia_automation import Trigger
from pydantic import BaseModel
import time

class UserEventConfiguration(BaseModel):
    frequency: int = 60

class UserEventData(BaseModel):
    user_id: str
    action: str
    timestamp: str

class UserEventTrigger(Trigger):
    configuration: UserEventConfiguration
    
    def run(self):
        """
        Continuously monitor for user events.
        This method runs in an infinite loop.
        """
        while True:
            # Fetch new event from external system
            event = self.fetch_next_event()
            
            # Launch a playbook run
            self.send_event(
                event_name="User Event",
                event={
                    "user_id": event.user_id,
                    "action": event.action,
                    "timestamp": event.timestamp
                }
            )
            
            # Wait before next poll
            time.sleep(self.configuration.frequency)
```

## Registration

Triggers MUST be registered in the module's `main.py` entrypoint.

### Registration Steps

1. Import the trigger class
2. Register the class with the module using `module.register()`
3. Pass the `docker_parameter` value as the second argument

**Example**:
```python
from module_name_module import ModuleClass
from module_name_module.triggers import UserEventTrigger

if __name__ == "__main__":
    module = ModuleClass()
    module.register(UserEventTrigger, "user_events")  # "user_events" matches docker_parameter
    module.run()
```

**Reference implementation**: See [Okta main.py](../Okta/main.py)

## Execution Pattern

Triggers typically follow this pattern:

```python
def run(self):
    while True:
        try:
            # 1. Fetch new event from source
            event = self.fetch_event()
            
            # 2. Send event to launch playbook run
            self.send_event(
                event_name="Event Type",
                event=event.to_dict()
            )
            
            # 3. Wait before next poll
            time.sleep(self.configuration.frequency)
            
        except Exception as e:
            self.log_exception(e)
            time.sleep(self.configuration.error_backoff)
```

## Schema Synchronization

**CRITICAL**: The Pydantic models in Python MUST match the JSON Schema in the manifest:
- Configuration model must match `arguments` schema
- Event data must match `results` schema
- Property names, types, and constraints must align

Mismatches will cause runtime validation errors.
